## LC 106. Construct Binary Tree from Inorder and Postorder Traversal
- Resource Analysis
    - Time: O(N)
    - Space: O(N)

- tags: [BST, Divide & Conquer, DP]

- Tips: 
    - Not yet  

- Implementation
    - Sol #1
        - Divide & Conquer
            - Not yet
            - Steps:
                1. while (queue 不是空的):
                    - 將 queue.front() 紀錄起來，這就是當前這層的最左邊的元素
                    - 一次 pop 等同於 queue.size() 數量的 node，
                      這樣就可以確保該次所拿的 node 一定都是屬於同一層的 

                2. 回傳記錄的元素
                 
    - Sol #2
        - 是最優解
        - Method:
            - 和 Sol #1 寫法幾乎一模一樣，只是多使用一個 hash table 來
              儲存「inorder[i] -> i」這樣的對應關係。
              
              利用這個 hash table，我們可以讓「在 inorder 裡找 postorder 最後一個元素」
              從原本的 O(N) 降到 O(1)，整體時間複雜度也可以降到 O(N) 
                    
- Solutions
    - 106_1.cpp
        - Sol #1: Divide & Conquer
        - Resource Analysis
            - Time: O(NlogN) ~ O(N^2)
            - Space: O(N) ~ O(N^2)

    - 106_2.cpp
        - Sol #2: Divide & Conquer + DP
        - Resource Analysis
            - Time: O(N)
            - Space: O(N)  

- Note
    - 如果需要大量地使用 O(N)-time 在 array 裡查找元素，通常都可以
      透過 hash table 事先存好「val->pos」的對應關係來降低時間複雜度  