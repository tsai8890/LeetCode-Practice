# LC 1049. Last Stone Weight II
> tags:  [DP] [Divide&Conquer] [KnapSack's]

## Summary 
1.  這題可以看成「選一些元素使得其和越接近總和的一半越好」，是一種「Knapsack Problem」的變形
    1.  可以把「石頭互動的過程」看成是「兩個石頭重量相減，產生一個新石頭」
    2.  「所有石頭互動的過程」可以看成是「所有石頭重量之間的加加減減」
    3.  「所有石頭重量之間的加加減減」其實就是「把石頭分成兩堆，一堆加上正號，一堆加上負號」
    
2.  Knapsack Problem 通常會這樣定義子問題
    - K(n, m) Definition
        - n: 給定 a1 ~ an 的物品，其重量分別為 w1 ~ wn，價值分別為 v1 ~ vn
        - m: 背包的重量限制
        - 目標: 最大化某個 target function
    - 本題
        - m = 重量總和的一半
        - target function: 最多可以塞多滿 (重量)

3.  可以使用 top-down or bottom-up DP
    - top-down 時間會比較快，因為不需要把整個二維 dp vector 都 traverse 一遍
    - bottom-up 可以透過壓縮 dp vector，把它變成一維的來節省空間

<br>

## Solutions
### Solution #1
#### Techniques
- Dynamic Programming (bottom-up)

#### Resource Analysis
> - N: 元素個數
> - M: 元素總和之半
- Time: O(NxM)
- Space: O(NxM)

#### Note
```
1.  使用 bottom-up DP，並使用最原本的二維 vector。
```


### Solution #2
#### Techniques
- Dynamic Programming (bottom-up)

#### Resource Analysis
> - N: 元素個數
> - M: 元素總和之半
- Time: O(NxM)
- Space: O(N)

#### Note
```
1.  使用 bottom-up DP，並使用一維 dp vector。
2.  這裡有一個小技巧，在遍歷一維 dp vector 的時候，要倒著遍歷，
    這樣才不會把前一層的資訊覆蓋掉。
```


### Solution #3
#### Techniques
- Dynamic Programming (top-down)

#### Resource Analysis
> - N: 元素個數
> - M: 元素總和之半
- Time: O(NxM) (遠小於 NxM)
- Space: O(NxM)

#### Note
```
1.  使用 top-down DP，在時間上是最快的，因為前面 bottom-up 的作法都一定要
    花 NxM 的時間來遍歷 (很多其實都不需要算)，而 top-down DP 只會遍歷到需要的部分，
    因此時間上會快很多。
```

